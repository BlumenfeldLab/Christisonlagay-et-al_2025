 %% Change directory to 
%% This is for getting channel labels after loading from EEGlab
% labels = {};
%
% for i = 1:length(EEG.chanlocs)
%     labels{i} = EEG.chanlocs(i).labels;
% end

% DEPENDECIES:
% edfread.m
% find_pulses.m
% read_mixed_csv.m
% verify_psychopy_ttl.m
% face_pulse.mat
% question_pulse.mat
% button_pulse.mat
% Subject's .edf files
% Subject's behavioral data .csv files


%% List of location of edf data files

files = {''};  %%list of lay file locations

%% Metafile
metafile = '' %%subject's meta file, not needed anywhere in analysis, but generated by task code and gives times of experiments, etc 

%% List of behavioral files

b_file = ''; %subject's combined behavioral files

%% List of folders with epochs extracted

folders = {''};

epochtypes = {'Tone_playback'}; %,'Questions','Buttons'};

 %% Analysis code below

 fs = 4096;

 load(metafile)
 load(b_file)

for h = 1:length(files)
    if ~exist(folders{h}, 'dir')
        mkdir(folders{h})
    end
    cd(folders{h});

    % NOTE: More runs than recording files, using run numbers in
    % containing folders to extract appropriate rows
    run_bounds = str2double(regexp(folders{h}, '\d+', 'match'));
    if numel(run_bounds) == 1
        run_range = run_bounds;
    else
        run_range = run_bounds(1):run_bounds(2);
    end

    trial_rows = find(any(allanswers_noiserun_all(:, 13) == run_range - 1, 2))';

    trial_identifier = cell(length(trial_rows), 1);
    delay_identifier = zeros(length(trial_rows), 1);
    type_identifier = zeros(length(trial_rows), 1);
    for j = trial_rows
        perception = '';
        % Fill in the perception accuracy for that row
        if allanswers_noiserun_all(j, 22) ~= 0 && allanswers_noiserun_all(j, 1) == 1
            perception = 'TP';
        elseif allanswers_noiserun_all(j, 22) ~= 0 && allanswers_noiserun_all(j, 1) == 2
            perception = 'FN';
        elseif allanswers_noiserun_all(j, 22) == 0 && allanswers_noiserun_all(j, 1) == 1
            perception = 'FP';
        elseif allanswers_noiserun_all(j, 22) == 0 && allanswers_noiserun_all(j, 1) == 2
            perception = 'TN';
        end

        % Fill in location accuracy for that row
        if strcmp(perception,'TP') && allanswers_noiserun_all(j, 3) == allanswers_noiserun_all(j, 22)
            trial_identifier{j - trial_rows(1) + 1} = 'Confirmed perceived';
        elseif strcmp(perception,'FN') && allanswers_noiserun_all(j, 3) ~= allanswers_noiserun_all(j, 22)
            trial_identifier{j - trial_rows(1) + 1} = 'Confirmed not perceived';
        elseif strcmp(perception,'FN') && allanswers_noiserun_all(j, 3) == allanswers_noiserun_all(j, 22)
            trial_identifier{j - trial_rows(1) + 1} = 'Correct guess';
        elseif strcmp(perception,'TP') && allanswers_noiserun_all(j, 3) ~= allanswers_noiserun_all(j, 22)
            trial_identifier{j - trial_rows(1) + 1} = 'False perception';
        elseif strcmp(perception,'TN')
            trial_identifier{j - trial_rows(1) + 1} = 'True Negative';
        elseif strcmp(perception,'FP')
            trial_identifier{j - trial_rows(1) + 1} = 'False Positive';
        end

        delay_identifier(j - trial_rows(1) + 1) = allanswers_noiserun_all(j, 10) - allanswers_noiserun_all(j, 11) - ...
            (allanswers_noiserun_all(j, 7) - 1) / allanswers_noiserun_all(j, 8);

        type_identifier(j - trial_rows(1) + 1) = allanswers_noiserun_all(j, 16);

    end

    delay_identifier = int64(delay_identifier);

    %% start reading the EDF of the EEG %% sEEG - I need to open the .raw file in EEGLab


    [hdr,record] = layread(files{h});
    labels = hdr.rawheader.channelmap;
    labels = regexprep(upper(labels), '-REF', '');


    %% Mark TTL pulses

    if h == 1
        record = record(:, (320 * fs):end);
    end


    % TTL pulse is on channel 191 for session 1, 192 for session 2 of 445JK
    if h == 1
        ttl_channel = 191;
    else
        ttl_channel = 192;
    end

    ttl = record(ttl_channel, :);
    time = 0:1/fs:(size(record, 2) - 1)/fs;
    plot(time, ttl);
    delete_channels = 157:size(record, 1);

    record(delete_channels,:) = [];
    labels(delete_channels) = [];

    %if ~exist('..\..\HNCT Auditory ID Combined\labels.mat', 'file')
    %    save('..\..\HNCT Auditory ID Combined\labels.mat', 'labels')
    %end

    %% Face pulses
    pulse_of_interest = 0.15; % We want 150ms pulses
    min_pulse_length = 0.025;
    max_pulse_length = 0.3;

    % Tolerance (valid pulses range from min_pulse_length-tol to
    % max_pulse_length+tol)
    tol = 0.005;

    % Pick a point (voltage value) that cuts through all the pulses
    query_point = 4000;

    [onsets, offsets] = find_pulses_CJM(ttl, fs, min_pulse_length, max_pulse_length, query_point, tol);
    durations = time(offsets) - time(onsets);
    tone_pulse_of_interest_onsets = find(abs(durations - pulse_of_interest) <= tol);

    disp(['TONE pulses in Session ' num2str(h) ': ' num2str(numel(tone_pulse_of_interest_onsets))])

    % plot identified 150ms face pulses on raw TTL signal for verification
    figure;
    % saveas(gcf,'stimulus_TTL_fig.fig');
    plot(time, ttl); hold on;
    plot(time(onsets(tone_pulse_of_interest_onsets)), zeros(1, numel(tone_pulse_of_interest_onsets)),'*r')
    xlabel('Time (s)')
    ylabel('TTL signal amplitude (\muV)')
    title('TTL tone pulses (in red) during task')

    % check face pulse indices against PsychoPy output
%     [face_mismatches, face_explanation] = verify_psychopy_ttl(face_pulse_of_interest_sample_idx, psychopy_faces);
%     display(face_explanation)

    %% Question onset pulses


    % find where faces are not followed by questions
%     for i = 1:length(face_pulse_of_interest_sample_idx)
%         if length(find(questionset_pulse_of_interest_sample_idx > face_pulse_of_interest_sample_idx(i) & questionset_pulse_of_interest_sample_idx < face_pulse_of_interest_sample_idx(i + 1))) ~= 2
%             display(i)
%         end
%     end


%     pulse_of_interest = 100; % We want 100ms pulses
%
%     load('ttl_100ms.mat')
%     [questionset_pulse_of_interest_sample_idx,~] = find_pulses(ttl, ttl_100ms, pulse_of_interest, 1);
%     disp(['QUESTION pulses in Run ' num2str(h) ': ' num2str(length(questionset_pulse_of_interest_sample_idx))])
%
%     figure;
%     plot(ttl); hold on;
%     plot(questionset_pulse_of_interest_sample_idx,zeros(1,length(questionset_pulse_of_interest_sample_idx)),'*r')
%     xlabel('TTL sample number')
%     ylabel('TTL signal amplitude (mV)')
%     title('TTL question pulses (in red) during task')
    % saveas(gcf,'question_TTL_fig.fig');

    % check question pulse indices against PsychoPy output
%     [question_mismatches, question_explanation] = verify_psychopy_ttl(questionset_pulse_of_interest_sample_idx, reshape(psychopy_questions,[1 numel(psychopy_questions)]));
%     display(question_explanation);

    %% Button press pulses
%     pulse_of_interest = 25; % We want 25ms pulses
%
%     load('button_pulse.mat')
%     [buttonpress_pulse_of_interest_sample_idx,~] = find_pulses(ttl, button_pulse, pulse_of_interest, 1);
%     disp(['BUTTON pulses in Run ' num2str(h) ': ' num2str(length(buttonpress_pulse_of_interest_sample_idx))])
%
%     figure;
%     plot(ttl); hold on;
%     plot(buttonpress_pulse_of_interest_sample_idx,zeros(1,length(buttonpress_pulse_of_interest_sample_idx)),'*r')
%     xlabel('TTL sample number')
%     ylabel('TTL signal amplitude (mV)')
%     title('TTL button pulses (in red) during task')
    % saveas(gcf,'button_TTL_fig.fig');

    % check button pulse indices against PsychoPy output
%     [button_mismatches, button_explanation] = verify_psychopy_ttl(buttonpress_pulse_of_interest_sample_idx, reshape(psychopy_buttons,[1 numel(psychopy_buttons)]));
%     display(button_explanation);

    %% EXTRACT EPOCHS (all faces, buttons, questions)

    % sampling frequency
    ttl_diode_offset = floor(.013 * fs);

%     EPOCHSTORAGE = struct();
%     EPOCHSTORAGE.labels = labels;


    for ei = 1:length(epochtypes)
        etype = epochtypes{ei};
        epochs = [];
        switch etype
            case 'Tone_playback'
                IDX = onsets(tone_pulse_of_interest_onsets);
                fixation_boolean = false;
                task_boolean = false;
            case 'Questions'
                IDX = questionset_pulse_of_interest_sample_idx;
                fixation_boolean = false;
                task_boolean = false;
            case 'Buttons'
                IDX = buttonpress_pulse_of_interest_sample_idx;
                fixation_boolean = false;
                task_boolean = false;
        end

        for i = 1:length(IDX)
            attempted_start_idx = IDX(i)-ttl_diode_offset-fs*1;
            attempted_stop_idx = IDX(i)-ttl_diode_offset+fs*1-1;
            epoch = record(:, max([1, attempted_start_idx]):min([attempted_stop_idx, length(record)]));
            epoch = -(epoch-repmat(nanmean(epoch(:,floor(.5*fs):fs),2),[1,size(epoch,2)]));

            % Pad with NaN if not enough data
            if attempted_start_idx < 1
                epoch = [NaN(size(epoch, 1), 1 - attempted_start_idx), epoch];
            end
            if attempted_stop_idx > length(record)
                epoch = [epoch, NaN(size(epoch, 1), attempted_stop_idx - length(record))];
            end
            epochs(:,:,i) = epoch;
        end


%         eval(['EPOCHSTORAGE.' etype ' = epochs;']);

        save(strcat(etype,'.mat'),'epochs','-v7.3');
%         save('EPOCHSTORAGE','EPOCHSTORAGE','-v7.3');

        %% saving longer epochs of -3 to +3/4/5 around tone playback time
        %{
        if ei == 1
            epochs = [];
            for i = 1:length(IDX)
                attempted_start_idx = IDX(i)-ttl_diode_offset-fs*3;
                attempted_stop_idx = IDX(i)-ttl_diode_offset+fs*delay_identifier(i)-1;
                epoch = NaN(size(record, 1), fs * 8);
                epoch = record(:, max([1, attempted_start_idx]):min([attempted_stop_idx, length(record)]));
                epoch = -(epoch-repmat(nanmean(epoch(:,1:3*fs),2),[1,size(epoch,2)]));

                % Pad with NaN if not enough data
                if attempted_start_idx < 1
                    epoch = [NaN(size(epoch, 1), 1 - attempted_start_idx), epoch];
                end
                if attempted_stop_idx > length(record)
                    epoch = [epoch, NaN(size(epoch, 1), attempted_stop_idx - length(record))];
                end
                epochs(:, 1:size(epoch, 2), i) = epoch;
            end
            save(strcat('extended_tone_epochs.mat'),'epochs','-v7.3');
        end
        %}
    end

    face_pulse_of_interest_sample_idx = onsets(tone_pulse_of_interest_onsets);

    % save the ttl times you found
    % right now this only includes faces but once questions and buttons are
    % worked out this should also include those times
    save('ttl_times.mat','face_pulse_of_interest_sample_idx','-v7.3')

    %% saving trial identifier information
    % now save a matrix of the identifiers so you can sort them later
    % identifiers are type (movie vs noise), delay (1 vs 15s), hemifield
    % (left vs right), or location accuracy (confirmed perceived, etc)
%     trial_identifier = raw(2:end,location);
%     hemifield_identifier = raw(2:end,hemifield);

    save('trial_identifiers', 'trial_identifier', 'type_identifier', 'delay_identifier', '-v7.3');

    close all
    clearvars -except folders files b_files h epochtypes allanswers_noiserun_all fs
    cd('..')

end
